name: Connect Integration Tests

on:
  workflow_call:
    inputs:
      extensions:
        description: "JSON array of extension names to test"
        required: true
        type: string
    outputs:
      successful_extensions:
        description: "Extensions that passed all tests"
        value: ${{ jobs.collect-results.outputs.successful_extensions }}
    secrets:
      CONNECT_LICENSE:
        required: true

jobs:
  # Determine the Connect versions to test against
  setup-integration-test:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      versions: ${{ steps.versions.outputs.versions }}
    steps:
      - uses: actions/checkout@v4
      - id: versions
        working-directory: ./integration
        # The `jq` command is "output compact, raw input, slurp, split on new lines, and remove the last element". This results in a JSON array of Connect versions (e.g., ["2025.01.0", "2024.12.0"]).
        run: |
          versions=$(make print-versions | jq -c -Rs 'split("\n") | .[:-1]')
          echo "Versions: $versions"
          echo "versions=$versions" >> "$GITHUB_OUTPUT"

  # Run the Connect integration tests for each extension against each Connect version
  connect-integration-test:
    runs-on: ubuntu-latest
    timeout-minutes: 15 # Max time to run the integration tests
    needs: setup-integration-test
    strategy:
      # Do not fail fast so all extensions and Connect versions are processed
      fail-fast: false
      matrix:
        extension: ${{ fromJson(inputs.extensions) }}
        connect_version: ${{ fromJson(needs.setup-integration-test.outputs.versions) }}
    steps:
      - uses: actions/checkout@v4

      - uses: ./.github/actions/connect-integration-test
        id: test
        with:
          extension-name: ${{ matrix.extension }}
          connect-version: ${{ matrix.connect_version }}
          connect-license: ${{ secrets.CONNECT_LICENSE }}

      - uses: actions/upload-artifact@v4
        if: |
          always() && 
          steps.test.outcome != 'cancelled' && 
          steps.test.outcome != 'skipped'
        with:
          name: ${{ matrix.extension }}-${{ matrix.connect_version }}-test-report          
          path: integration/reports/*.xml
          retention-days: 7

  # Analyses the test result files and publishes the results on the GitHub Actions job summary page
  integration-test-report:
    needs: connect-integration-test
    runs-on: ubuntu-latest
    timeout-minutes: 5
    # Create a matrix so each extension gets its own test report
    strategy:
      fail-fast: false
      matrix:
        extension: ${{ fromJson(inputs.extensions) }}
    permissions:
      checks: write
      pull-requests: write
    # Only run if tests weren't skipped or cancelled
    if: |
      always() && 
      !contains(needs.connect-integration-test.result, 'skipped') &&
      !contains(needs.connect-integration-test.result, 'cancelled')
    steps:
      - uses: actions/download-artifact@v4
        id: download
        with:
          path: artifacts
          pattern: "${{ matrix.extension }}-*-test-report" 

      - uses: EnricoMi/publish-unit-test-result-action@v2
        if: ${{ steps.download.outputs.download-path != '' }}
        with:
          check_name: "Integration test results - ${{ matrix.extension }}"
          comment_mode: off
          files: "artifacts/**/*.xml"
          report_individual_runs: true

  # Provides a matrix of extensions that passed all of the Connect integration tests
  collect-results:
    needs: [connect-integration-test, setup-integration-test]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      successful_extensions: ${{ steps.collect.outputs.successful_extensions }}
    if: |
      !contains(needs.connect-integration-test.result, 'skipped') &&
      !contains(needs.connect-integration-test.result, 'cancelled')
    steps:
      - id: collect
        run: |
          # Validate inputs first
          all_versions='${{ needs.setup-integration-test.outputs.versions }}'
          extensions='${{ inputs.extensions }}'

          if [[ -z "$all_versions" || -z "$extensions" ]]; then
            echo "❌ Missing required inputs"
            exit 1
          fi

          # Get matrix results from job context
          matrix_results='${{ toJSON(needs.connect-integration-test) }}'

          if [[ -z "$matrix_results" || "$matrix_results" == "{}" ]]; then
            echo "❌ No matrix results found"
            echo "successful_extensions=[]" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Debug: Full matrix context:"
          echo "$matrix_results" | jq '.'

          # Track extensions that passed ALL version tests
          success_list=()

          # Process each extension
          for ext in $(echo "$extensions" | jq -r '.[]'); do
            all_passed=true
            echo "📦 Checking extension: $ext"
            
            # Check if matrix results has jobs array (simple-extensions case)
            # or just a single result (publisher-command-center case)
            if echo "$matrix_results" | jq -e '.jobs' >/dev/null 2>&1; then
              echo "Using matrix job results structure"
              # Must pass ALL versions
              for version in $(echo "$all_versions" | jq -r '.[]'); do
                echo "🔎 Checking $ext @ $version"
                
                # Get specific matrix combination result
                result=$(echo "$matrix_results" | jq -r \
                  --arg ext "$ext" \
                  --arg ver "$version" \
                  '.jobs[] | select(.matrix.extension == $ext and .matrix.connect_version == $ver) | .result')
                
                if [[ -z "$result" ]]; then
                  echo "❌ No result found for $ext @ $version"
                  all_passed=false
                  break
                elif [[ "$result" != "success" ]]; then
                  echo "❌ Failed: $ext @ $version ($result)"
                  all_passed=false
                  break
                else 
                  echo "✅ Passed: $ext @ $version"
                fi
              done
            else
              # Single result case (publisher-command-center)
              echo "Using single job result structure"
              result=$(echo "$matrix_results" | jq -r '.result')
              
              if [[ "$result" != "success" ]]; then
                echo "❌ Failed: $ext (result: $result)"
                all_passed=false
              else
                echo "✅ Passed: $ext"
              fi
            fi
            
            if [[ "$all_passed" == "true" ]]; then
              success_list+=("$ext")
              echo "🎉 SUCCESS: $ext passed ALL versions"
            else
              echo "⚠️ FAILED: $ext failed one or more versions"
            fi
          done

          # Format output
          successful_extensions=$(jq -n --arg arr "$(IFS=,; echo "${success_list[*]}")" \
            '$arr | split(",")' -c)

          if [[ -z "$successful_extensions" || "$successful_extensions" == "[]" ]]; then
            echo "⚠️ No extensions passed all tests"
            echo "successful_extensions=[]" >> $GITHUB_OUTPUT
          else
            echo "📊 Final successful extensions: $successful_extensions"
            echo "successful_extensions=$successful_extensions" >> $GITHUB_OUTPUT
          fi

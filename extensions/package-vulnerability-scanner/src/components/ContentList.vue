<script setup lang="ts">
import { computed, ref, watch } from "vue";
import { storeToRefs } from "pinia";

import { usePackagesStore } from "../stores/packages";
import { useContentStore } from "../stores/content";
import { useScannerStore } from "../stores/scanner";
import { useUserStore } from "../stores/user";
import type { User } from "../stores/user";
import StatusMessage from "./ui/StatusMessage.vue";
import SkeletonText from "./ui/SkeletonText.vue";
import BadgeTabs, { type Tab } from "./ui/BadgeTabs.vue";
import ContentCard from "./ContentCard.vue";
import SortDropdown, {
  type SortSelection,
  type SortOption,
} from "./ui/SortDropdown.vue";

const props = defineProps<{
  user: User;
}>();

const userStore = useUserStore();

const packagesStore = usePackagesStore();
const contentStore = useContentStore();
const scannerStore = useScannerStore();

// Use store's showAllContent to persist state across remounts
const { showAllContent } = storeToRefs(contentStore);

// Watch for toggle changes and refetch content
watch(showAllContent, async () => {
  packagesStore.clearAllPackages();
  await contentStore.fetchContentList(true);
  fetchPackagesInBatches();
});

// Fetch packages in batches to avoid overwhelming the server
async function fetchPackagesInBatches(batchSize = 3) {
  const contentToFetch = contentStore.contentList.filter(
    (content) =>
      !packagesStore.contentItems[content.guid]?.isFetched &&
      !packagesStore.contentItems[content.guid]?.isLoading,
  );

  // Process in batches
  for (let i = 0; i < contentToFetch.length; i += batchSize) {
    const batch = contentToFetch.slice(i, i + batchSize);

    // Fetch packages for this batch in parallel
    const fetchPromises = batch.map(async (content) => {
      if (content.bundle_id === null) {
        packagesStore.setPackagesForContent(
          content.guid,
          [],
          new Error("This content has not been fully deployed."),
        );
        return;
      }
      try {
        return await packagesStore.fetchPackagesForContent(content.guid);
      } catch (err) {
        return console.error(
          `Error fetching packages for ${content.guid}:`,
          err,
        );
      }
    });

    await Promise.all(fetchPromises);
  }
}

fetchPackagesInBatches();

const tabs = computed<Tab[]>(() => {
  const result: Tab[] = [];

  result.push({
    name: "All",
    color: "primary",
    count: scannerStore.content.length,
  });

  result.push({
    name: "With Vulnerabilities",
    color: "error",
    count: scannerStore.anyContentLoadingPackages
      ? undefined
      : scannerStore.contentWithVulnerabilities.length,
  });

  return result;
});

const activeTab = ref("All");

const sortOptions: SortOption[] = [
  {
    id: "last-deployment-date",
    label: "Last Deployment date",
    sortOrderDefault: "desc",
    sortOrderOptions: [
      {
        id: "newest",
        label: "Newest",
        sortOrder: "desc",
      },
      {
        id: "oldest",
        label: "Oldest",
        sortOrder: "asc",
      },
    ],
  },
  {
    id: "vulnerabilities",
    label: "Vulnerabilities",
    sortOrderDefault: "desc",
    sortOrderOptions: [
      {
        id: "most",
        label: "Most",
        sortOrder: "desc",
      },
      {
        id: "least",
        label: "Least",
        sortOrder: "asc",
      },
    ],
  },
] as const;

const activeSortOption = ref<SortSelection>({
  id: "last-deployment-date",
  label: "Last Deployment date",
  sortOrder: "desc",
});

const filteredContent = computed(() => {
  let content = [...scannerStore.content];

  if (activeTab.value === "With Vulnerabilities") {
    content = scannerStore.contentWithVulnerabilities;
  }

  content = content.sort((a, b) => {
    if (activeSortOption.value.id === "last-deployment-date") {
      const dateA = new Date(a.last_deployed_time || 0);
      const dateB = new Date(b.last_deployed_time || 0);

      return activeSortOption.value.sortOrder === "desc"
        ? dateB.getTime() - dateA.getTime()
        : dateA.getTime() - dateB.getTime();
    } else if (activeSortOption.value.id === "vulnerabilities") {
      return activeSortOption.value.sortOrder === "desc"
        ? b.vulnerabilityCount - a.vulnerabilityCount
        : a.vulnerabilityCount - b.vulnerabilityCount;
    }
    return 0;
  });

  return content;
});

const userHeader = computed(() => {
  if (showAllContent.value) {
    return "All Content on Connect";
  }

  let name;

  if (props.user.first_name && props.user.last_name) {
    name = `${props.user.first_name} ${props.user.last_name}`;
  } else if (props.user.first_name) {
    name = props.user.first_name;
  } else if (props.user.last_name) {
    name = props.user.last_name;
  }

  if (name === undefined) {
    name = props.user.username;
  }

  return `${name}'s Content on Connect`;
});
</script>

<template>
  <div class="mb-10 p-5 bg-white rounded-lg shadow-md">
    <div v-if="contentStore.error">
      <StatusMessage
        type="error"
        message="Error loading content"
        :details="contentStore.error.message"
      />
    </div>

    <div v-else-if="!scannerStore.hasContent">
      <StatusMessage
        type="warning"
        message="No content found"
        details="No published content was found on this Connect server."
      />
    </div>

    <div v-else class="space-y-4">
      <div class="flex items-center justify-between">
        <h2 class="text-xl font-semibold text-gray-800">
          {{ userHeader }}
        </h2>

        <label v-if="userStore.isAdmin" class="flex items-center gap-2 cursor-pointer">
          <span class="text-sm text-gray-600">show:</span>
          <span class="text-sm" :class="showAllContent ? 'text-gray-600' : 'text-gray-800 font-medium'">only mine</span>
          <div class="relative">
            <input
              type="checkbox"
              v-model="showAllContent"
              class="sr-only peer"
            />
            <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
          </div>
          <span class="text-sm" :class="showAllContent ? 'text-gray-800 font-medium' : 'text-gray-600'">all</span>
        </label>
      </div>

      <p class="text-gray-600">
        Found {{ scannerStore.content.length }} content items with
        <SkeletonText
          v-if="scannerStore.anyContentLoadingPackages"
          class="h-6 w-[2ch]"
        />
        <span v-else>{{ scannerStore.totalVulnerabilities }}</span>
        vulnerabilities.
      </p>

      <p class="text-gray-600">
        Select a content item to see details on package vulnerabilities.
      </p>

      <div class="flex items-center justify-between border-b border-gray-200">
        <BadgeTabs v-model="activeTab" :tabs="tabs" />

        <SortDropdown v-model="activeSortOption" :sort-options="sortOptions" />
      </div>

      <div class="grid gap-4">
        <ContentCard
          v-for="content in filteredContent"
          :key="content.guid"
          :content="content"
        />
      </div>
    </div>
  </div>
</template>

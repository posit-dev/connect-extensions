<script setup lang="ts">
import { useVulnsStore } from "../stores/vulns";
import { usePackagesStore } from "../stores/packages";
import { useContentStore } from "../stores/content";
import { computed, ref } from "vue";

// Import UI components
import LoadingSpinner from "./ui/LoadingSpinner.vue";
import StatusMessage from "./ui/StatusMessage.vue";

// Import vulnerability components
import StatsPanel, { type FilterType } from "./vulnerability/StatsPanel.vue";
import EmptyState from "./vulnerability/EmptyState.vue";
import PackageList from "./vulnerability/PackageList.vue";
import ArrowTopRight from "./icons/ArrowTopRight.vue";
import type { PackageWithVulnsAndFix } from "../types";

const vulnStore = useVulnsStore();
const packagesStore = usePackagesStore();
const contentStore = useContentStore();

const packages = computed((): PackageWithVulnsAndFix[] => {
  // Get the current content's packages
  const currentId = contentStore.currentContentId;
  if (!currentId) return [];

  const contentItem = packagesStore.contentItems[currentId];
  const result = contentItem ? contentItem.packages : [];

  return result.map((pkg): PackageWithVulnsAndFix => {
    return {
      package: pkg,
      ...vulnStore.getDetailsForPackageVersion(
        pkg.name,
        pkg.version,
        pkg.language.toLowerCase() === "python" ? "pypi" : "cran",
      ),
    };
  });
});

// Track loading states
const isLoadingVulns = computed(() => vulnStore.isLoading);
const isLoadingPackages = computed(() => {
  // Check if the current content is loading
  const currentId = contentStore.currentContentId;
  if (!currentId) return false;

  const contentItem = packagesStore.contentItems[currentId];
  return contentItem ? contentItem.isLoading : false;
});
const isLoading = computed(
  () => isLoadingPackages.value || isLoadingVulns.value,
);
const hasError = computed(() => {
  const currentId = contentStore.currentContentId;
  if (!currentId) return vulnStore.error;

  const contentItem = packagesStore.contentItems[currentId];
  return vulnStore.error || (contentItem ? contentItem.error : null);
});

// Check if we have packages to analyze
const hasPackages = computed(() => {
  return packages.value.length > 0;
});

// Go back to content list
function goBack() {
  contentStore.currentContentId = undefined;
  scrollTo({ top: 0, left: 0, behavior: "instant" });
}

// Find vulnerable packages by comparing package data with vulnerability data
const vulnerablePackages = computed((): PackageWithVulnsAndFix[] => {
  return packages.value.filter((pkg) => {
    return pkg.vulnerabilities && pkg.vulnerabilities.length > 0;
  });
});

// Status messages based on loading state
const loadingMessage = computed(() => {
  if (isLoadingPackages.value && isLoadingVulns.value) {
    return "Loading package and vulnerability data...";
  } else if (isLoadingPackages.value) {
    return "Loading package data...";
  } else if (isLoadingVulns.value) {
    return "Loading vulnerability data...";
  }
  return "";
});

// Get the current content information and derived properties
const contentInfo = computed(() => contentStore.currentContent);
const contentTitle = computed(
  () => contentInfo.value?.title || "Unnamed Content",
);
const dashboardUrl = computed(() => contentInfo.value?.dashboard_url || null);

const pythonPackages = computed((): PackageWithVulnsAndFix[] => {
  if (isLoading.value || !packages.value.length) return [];
  return packages.value.filter(
    (p) => p.package.language.toLowerCase() === "python",
  );
});

const rPackages = computed((): PackageWithVulnsAndFix[] => {
  if (isLoading.value || !packages.value.length) return [];
  return packages.value.filter((p) => p.package.language.toLowerCase() === "r");
});

// Total number of vulnerabilities (CVEs) across all packages
const totalVulnerabilities = computed(() => {
  return vulnerablePackages.value.reduce((total, pkg) => {
    return total + (pkg.vulnerabilities ? pkg.vulnerabilities.length : 0);
  }, 0);
});

const activeFilter = ref<FilterType>("vulnerable");

const filterTitle = computed(() => {
  switch (activeFilter.value) {
    case "all":
      return "All Packages";
    case "python":
      return "Python Packages";
    case "r":
      return "R Packages";
    case "vulnerable":
      return "Vulnerable Packages";
    default:
      return "Packages";
  }
});

// Use the filtered arrays for the displayed packages
const filteredPackages = computed((): PackageWithVulnsAndFix[] => {
  if (isLoading.value || !packages.value.length) return [];

  switch (activeFilter.value) {
    case "python":
      return pythonPackages.value;
    case "r":
      return rPackages.value;
    case "vulnerable":
      return vulnerablePackages.value;
    default:
      return packages.value;
  }
});
</script>

<template>
  <button
    @click="goBack"
    class="px-4 py-2 mb-4 bg-white shrink-0 cursor-pointer hover:bg-gray-200 text-gray-800 rounded-md shadow-sm hover:shadow-md transition-colors"
  >
    ‚Üê Back to Content List
  </button>

  <div class="max-w-4xl mx-auto p-5 bg-white rounded-lg shadow-md">
    <!-- Content header with title and back button -->
    <div class="flex justify-between items-center mb-6">
      <div>
        <h2 class="text-xl font-semibold">{{ contentTitle }}</h2>
        <div class="flex flex-wrap space-x-2 mb-1">
          <p class="text-sm text-gray-500">
            {{ contentStore.currentContentId }}
          </p>
          <a
            v-if="dashboardUrl"
            :href="dashboardUrl"
            target="_blank"
            rel="noopener noreferrer"
            class="text-sm text-blue-600 hover:text-blue-800 flex items-center"
          >
            <span>View on Connect</span>
            <ArrowTopRight class="ml-1" />
          </a>
        </div>
        <div
          v-if="contentInfo"
          class="flex flex-wrap gap-x-4 text-sm text-gray-600"
        >
          <span v-if="contentInfo.py_version"
            >Python: {{ contentInfo.py_version }}</span
          >
          <span v-if="contentInfo.r_version"
            >R: {{ contentInfo.r_version }}</span
          >
          <span v-if="contentInfo.quarto_version"
            >Quarto: {{ contentInfo.quarto_version }}</span
          >
        </div>
      </div>
    </div>

    <!-- Loading state -->
    <LoadingSpinner v-if="isLoading" :message="loadingMessage" size="md" />

    <!-- Error state -->
    <StatusMessage
      v-else-if="hasError"
      type="error"
      message="Error analyzing packages. The content may not be fully deployed."
    />

    <!-- Content loaded successfully -->
    <template v-else>
      <StatsPanel
        v-model="activeFilter"
        :totalPackages="packages.length"
        :pythonPackages="pythonPackages.length"
        :rPackages="rPackages.length"
        :vulnerabilities="totalVulnerabilities"
      />

      <h3 class="text-lg text-gray-700 mb-4">{{ filterTitle }}</h3>

      <EmptyState v-if="!hasPackages">
        <p>This content has no packages. No vulnerabilities found.</p>
      </EmptyState>

      <EmptyState v-else-if="filteredPackages.length === 0">
        <p v-if="activeFilter === 'vulnerable'">No vulnerabilities found.</p>
        <p v-else-if="activeFilter === 'python'">No Python packages found.</p>
        <p v-else-if="activeFilter === 'r'">No R packages found.</p>
        <p v-else>No packages found.</p>
      </EmptyState>

      <PackageList v-else :packages="filteredPackages" />
    </template>
  </div>
</template>

import { defineStore } from "pinia";
import { ref } from "vue";

export interface VulnerabilityEvent {
  introduced?: string;
  fixed?: string;
}

export interface VulnerabilityRange {
  type: string;
  events: VulnerabilityEvent[];
}

export interface Vulnerability {
  id: string;
  versions: Record<string, any>;
  ranges: VulnerabilityRange[];
  summary: string;
  details: string;
  modified: string;
  published: string;
}

export interface VulnerabilityMap {
  [packageName: string]: Vulnerability[];
}

export const useVulnsStore = defineStore("vulns", () => {
  // State
  const pypi = ref<VulnerabilityMap>({});
  const cran = ref<VulnerabilityMap>({});
  const isLoading = ref(false);
  const error = ref<Error | null>(null);

  // Track fetch status
  const isFetched = ref(false);
  const lastFetchTime = ref<Date | null>(null);

  // Actions
  async function fetchVulns() {
    isLoading.value = true;
    error.value = null;

    try {
      const response = await fetch("api/vulns");

      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }

      const data = await response.json();

      pypi.value = data.pypi || {};
      cran.value = data.cran || {};
      isFetched.value = true;
      lastFetchTime.value = new Date();
    } catch (err) {
      console.error("Error fetching vulnerabilities:", err);
      error.value = err as Error;
    } finally {
      isLoading.value = false;
    }
  }

  // Extract the fixed version from the vulnerability ranges data
  function getFixedVersion(vuln: Vulnerability): string | null {
    if (
      !vuln.ranges ||
      !Array.isArray(vuln.ranges) ||
      vuln.ranges.length === 0
    ) {
      return null;
    }

    let result: string | null = null;

    const getFixedEventValue = (range: VulnerabilityRange): string | null => {
      return range.events.find((e) => Boolean(e.fixed))?.fixed || null;
    };

    for (const range of vuln.ranges) {
      if (range.type === "ECOSYSTEM" && range.events) {
        return getFixedEventValue(range);
      } else {
        result = getFixedEventValue(range);
      }
    }

    return result;
  }

  function getDetailsForPackageVersion(
    packageName: string,
    version: string,
    repo: "pypi" | "cran",
  ): {
    vulnerabilities: Vulnerability[];
    latestFixedVersion: string | null;
  } {
    const vulns: Vulnerability[] = [];
    const fixVersions: string[] = [];
    const vulnsMap = repo === "pypi" ? pypi.value : cran.value;

    // If this package has known vulnerabilities
    if (vulnsMap[packageName]) {
      // For each vulnerability associated with this package
      for (const vuln of vulnsMap[packageName]) {
        // Check if the current package version is in the vulnerable versions
        if (vuln.versions && vuln.versions[version]) {
          const fixedVersion = getFixedVersion(vuln);
          if (fixedVersion) {
            fixVersions.push(fixedVersion);
          }
          vulns.push(vuln);
        }
      }
    }

    const sortedFixedVersions = fixVersions.sort((a, b) => {
      const aParts = a.split(".");
      const bParts = b.split(".");

      for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
        const aNum = parseInt(aParts[i] || "0", 10);
        const bNum = parseInt(bParts[i] || "0", 10);
        if (aNum !== bNum) {
          return bNum - aNum; // Descending order (latest first)
        }
      }

      return 0;
    });

    return {
      vulnerabilities: vulns,
      latestFixedVersion:
        sortedFixedVersions.length > 0 ? sortedFixedVersions[0] : null,
    };
  }

  return {
    // State
    pypi,
    cran,
    isLoading,
    error,
    isFetched,
    lastFetchTime,

    // Actions
    fetchVulns,
    getDetailsForPackageVersion,
  };
});

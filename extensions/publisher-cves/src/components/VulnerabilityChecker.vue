<script setup lang="ts">
import { useVulnsStore } from '../stores/vulns';
import { usePackagesStore } from '../stores/packages';
import type { Vulnerability } from '../stores/vulns';
import type { Package } from '../stores/packages';
import { computed } from 'vue';

// Import UI components
import LoadingSpinner from './ui/LoadingSpinner.vue';
import StatusMessage from './ui/StatusMessage.vue';
import ContentHeader from './ui/ContentHeader.vue';

// Import vulnerability components
import StatsPanel from './vulnerability/StatsPanel.vue';
import EmptyState from './vulnerability/EmptyState.vue';
import VulnerabilityList from './vulnerability/VulnerabilityList.vue';

interface VulnerablePackageItem {
  packageInfo: Package;
  vulnerabilities: Vulnerability[];
  repo: 'pypi' | 'cran';
  latestFixedVersion: string | null;
}

const vulnStore = useVulnsStore();
const packagesStore = usePackagesStore();

// Track loading states
const isLoadingVulns = computed(() => vulnStore.isLoading);
const isLoadingPackages = computed(() => packagesStore.isLoading);
const isLoading = computed(() => isLoadingPackages.value || isLoadingVulns.value);
const hasError = computed(() => vulnStore.error || packagesStore.error);

// Check if we have packages to analyze
const hasPackages = computed(() => packagesStore.isFetched && packagesStore.packages.length > 0);

// Extract the fixed version from the vulnerability ranges data
function getFixedVersion(vuln: Vulnerability): string | null {
  if (!vuln.ranges || !Array.isArray(vuln.ranges) || vuln.ranges.length === 0) {
    return null;
  }

  // Look through all ranges
  for (const range of vuln.ranges) {
    // Look for events with a "fixed" property
    if (range.events && Array.isArray(range.events)) {
      for (const event of range.events) {
        if (event.fixed) {
          return event.fixed;
        }
      }
    }
  }

  return null;
}

// Find vulnerable packages by comparing package data with vulnerability data
const vulnerablePackages = computed<VulnerablePackageItem[]>(() => {
  if (isLoading.value || !packagesStore.packages.length || !vulnStore.isFetched) return [];

  // Use a Map to group vulnerabilities by package
  const packageMap = new Map<string, {
    packageInfo: Package;
    vulnerabilities: Vulnerability[];
    repo: 'pypi' | 'cran';
    fixedVersions: string[];
  }>();

  // Process each installed package
  for (const pkg of packagesStore.packages) {
    const packageId = `${pkg.name}@${pkg.version}`;
    const repo = pkg.language.toLowerCase() === 'python' ? 'pypi' : 'cran';
    const vulnerabilityMap = repo === 'pypi' ? vulnStore.pypi : vulnStore.cran;
    const packageName = pkg.name.toLowerCase();

    // If this package has known vulnerabilities
    if (vulnerabilityMap[packageName]) {
      // For each vulnerability associated with this package
      for (const vuln of vulnerabilityMap[packageName]) {
        // Check if the current package version is in the vulnerable versions
        if (vuln.versions && vuln.versions[pkg.version]) {
          const fixedVersion = getFixedVersion(vuln);

          if (!packageMap.has(packageId)) {
            packageMap.set(packageId, {
              packageInfo: pkg,
              vulnerabilities: [],
              repo,
              fixedVersions: []
            });
          }

          const packageData = packageMap.get(packageId)!;
          packageData.vulnerabilities.push(vuln);

          if (fixedVersion) {
            packageData.fixedVersions.push(fixedVersion);
          }
        }
      }
    }
  }

  // Convert the Map to an array and determine the latest fixed version
  return Array.from(packageMap.values()).map(item => {
    // Sort fixed versions semantically (assuming they are valid semver)
    // This simple comparison works for most simple version formats
    const sortedFixedVersions = [...item.fixedVersions].sort((a, b) => {
      const aParts = a.split('.');
      const bParts = b.split('.');

      for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
        const aNum = parseInt(aParts[i] || '0', 10);
        const bNum = parseInt(bParts[i] || '0', 10);
        if (aNum !== bNum) {
          return bNum - aNum; // Descending order (latest first)
        }
      }

      return 0;
    });

    return {
      packageInfo: item.packageInfo,
      vulnerabilities: item.vulnerabilities,
      repo: item.repo,
      latestFixedVersion: sortedFixedVersions.length > 0 ? sortedFixedVersions[0] : null
    };
  });
});

// Status messages based on loading state
const loadingMessage = computed(() => {
  if (isLoadingPackages.value && isLoadingVulns.value) {
    return 'Loading package and vulnerability data...';
  } else if (isLoadingPackages.value) {
    return 'Loading package data...';
  } else if (isLoadingVulns.value) {
    return 'Loading vulnerability data...';
  }
  return '';
});

// Stats
const totalPackages = computed(() => packagesStore.packages.length);
const pythonPackages = computed(() =>
  packagesStore.packages.filter(p => p.language.toLowerCase() === 'python').length
);
const rPackages = computed(() =>
  packagesStore.packages.filter(p => p.language.toLowerCase() === 'r').length
);

// Total number of vulnerabilities (CVEs) across all packages
const totalVulnerabilities = computed(() => {
  return vulnerablePackages.value.reduce((total, pkg) => {
    return total + pkg.vulnerabilities.length;
  }, 0);
});
</script>

<template>
  <!-- Only show the component if we have content to analyze -->
  <div v-if="hasPackages || isLoadingPackages" class="max-w-4xl mx-auto p-5 bg-white rounded-lg shadow-md">
    <!-- Content header with GUID -->
    <ContentHeader v-if="packagesStore.currentContentId" :contentId="packagesStore.currentContentId" />

    <!-- Loading state -->
    <LoadingSpinner v-if="isLoading" :message="loadingMessage" size="md" />

    <!-- Error state -->
    <StatusMessage v-else-if="hasError" type="error" message="Error analyzing packages. Please try again." />

    <!-- Content loaded successfully -->
    <div v-else-if="hasPackages">
      <!-- Stats panel -->
      <StatsPanel :totalPackages="totalPackages" :pythonPackages="pythonPackages" :rPackages="rPackages"
        :vulnerabilities="totalVulnerabilities" />

      <!-- No vulnerabilities found -->
      <EmptyState v-if="vulnerablePackages.length === 0">
        <p>All packages are safe! No vulnerabilities found.</p>
      </EmptyState>

      <!-- Vulnerability list -->
      <VulnerabilityList v-else :vulnerablePackages="vulnerablePackages" />
    </div>
  </div>
</template>

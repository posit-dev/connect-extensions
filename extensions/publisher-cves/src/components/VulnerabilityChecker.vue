<script setup lang="ts">
import { useVulnsStore } from "../stores/vulns";
import { usePackagesStore } from "../stores/packages";
import { useContentStore } from "../stores/content";
import type { Vulnerability } from "../stores/vulns";
import type { Package } from "../stores/packages";
import { computed } from "vue";

// Import UI components
import LoadingSpinner from "./ui/LoadingSpinner.vue";
import StatusMessage from "./ui/StatusMessage.vue";

// Import vulnerability components
import StatsPanel from "./vulnerability/StatsPanel.vue";
import EmptyState from "./vulnerability/EmptyState.vue";
import VulnerabilityList from "./vulnerability/VulnerabilityList.vue";
import ArrowTopRight from "./icons/ArrowTopRight.vue";

interface VulnerablePackageItem {
  packageInfo: Package;
  vulnerabilities: Vulnerability[];
  repo: "pypi" | "cran";
  latestFixedVersion: string | null;
}

const vulnStore = useVulnsStore();
const packagesStore = usePackagesStore();
const contentStore = useContentStore();

const packages = computed(() => {
  // Get the current content's packages
  const currentId = contentStore.currentContentId;
  if (!currentId) return [];

  const contentItem = packagesStore.contentItems[currentId];
  return contentItem ? contentItem.packages : [];
});

// Track loading states
const isLoadingVulns = computed(() => vulnStore.isLoading);
const isLoadingPackages = computed(() => {
  // Check if the current content is loading
  const currentId = contentStore.currentContentId;
  if (!currentId) return false;

  const contentItem = packagesStore.contentItems[currentId];
  return contentItem ? contentItem.isLoading : false;
});
const isLoading = computed(
  () => isLoadingPackages.value || isLoadingVulns.value,
);
const hasError = computed(() => {
  const currentId = contentStore.currentContentId;
  if (!currentId) return vulnStore.error;

  const contentItem = packagesStore.contentItems[currentId];
  return vulnStore.error || (contentItem ? contentItem.error : null);
});

// Check if we have packages to analyze
const hasPackages = computed(() => {
  return packages.value.length > 0;
});

// Extract the fixed version from the vulnerability ranges data
function getFixedVersion(vuln: Vulnerability): string | null {
  if (!vuln.ranges || !Array.isArray(vuln.ranges) || vuln.ranges.length === 0) {
    return null;
  }

  // Look through all ranges
  for (const range of vuln.ranges) {
    // Look for events with a "fixed" property
    if (range.events && Array.isArray(range.events)) {
      for (const event of range.events) {
        if (event.fixed) {
          return event.fixed;
        }
      }
    }
  }

  return null;
}

// Go back to content list
function goBack() {
  contentStore.currentContentId = undefined;
}

// Find vulnerable packages by comparing package data with vulnerability data
const vulnerablePackages = computed<VulnerablePackageItem[]>(() => {
  if (isLoading.value || !packages.value.length || !vulnStore.isFetched)
    return [];

  // Use a Map to group vulnerabilities by package
  const packageMap = new Map<
    string,
    {
      packageInfo: Package;
      vulnerabilities: Vulnerability[];
      repo: "pypi" | "cran";
      fixedVersions: string[];
    }
  >();

  // Process each installed package
  for (const pkg of packages.value) {
    const packageId = `${pkg.name}@${pkg.version}`;
    const repo = pkg.language.toLowerCase() === "python" ? "pypi" : "cran";
    const vulnerabilityMap = repo === "pypi" ? vulnStore.pypi : vulnStore.cran;
    const packageName = pkg.name.toLowerCase();

    // If this package has known vulnerabilities
    if (vulnerabilityMap[packageName]) {
      // For each vulnerability associated with this package
      for (const vuln of vulnerabilityMap[packageName]) {
        // Check if the current package version is in the vulnerable versions
        if (vuln.versions && vuln.versions[pkg.version]) {
          const fixedVersion = getFixedVersion(vuln);

          if (!packageMap.has(packageId)) {
            packageMap.set(packageId, {
              packageInfo: pkg,
              vulnerabilities: [],
              repo,
              fixedVersions: [],
            });
          }

          const packageData = packageMap.get(packageId)!;
          packageData.vulnerabilities.push(vuln);

          if (fixedVersion) {
            packageData.fixedVersions.push(fixedVersion);
          }
        }
      }
    }
  }

  // Convert the Map to an array and determine the latest fixed version
  return Array.from(packageMap.values()).map((item) => {
    // Sort fixed versions semantically (assuming they are valid semver)
    // This simple comparison works for most simple version formats
    const sortedFixedVersions = [...item.fixedVersions].sort((a, b) => {
      const aParts = a.split(".");
      const bParts = b.split(".");

      for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
        const aNum = parseInt(aParts[i] || "0", 10);
        const bNum = parseInt(bParts[i] || "0", 10);
        if (aNum !== bNum) {
          return bNum - aNum; // Descending order (latest first)
        }
      }

      return 0;
    });

    return {
      packageInfo: item.packageInfo,
      vulnerabilities: item.vulnerabilities,
      repo: item.repo,
      latestFixedVersion:
        sortedFixedVersions.length > 0 ? sortedFixedVersions[0] : null,
    };
  });
});

// Status messages based on loading state
const loadingMessage = computed(() => {
  if (isLoadingPackages.value && isLoadingVulns.value) {
    return "Loading package and vulnerability data...";
  } else if (isLoadingPackages.value) {
    return "Loading package data...";
  } else if (isLoadingVulns.value) {
    return "Loading vulnerability data...";
  }
  return "";
});

// Get the current content information and derived properties
const contentInfo = computed(() => contentStore.currentContent);
const contentTitle = computed(
  () => contentInfo.value?.title || "Unnamed Content",
);
const dashboardUrl = computed(() => contentInfo.value?.dashboard_url || null);

// Stats
const totalPackages = computed(() => packages.value.length);
const pythonPackages = computed(
  () =>
    packages.value.filter((p) => p.language.toLowerCase() === "python").length,
);
const rPackages = computed(
  () => packages.value.filter((p) => p.language.toLowerCase() === "r").length,
);

// Total number of vulnerabilities (CVEs) across all packages
const totalVulnerabilities = computed(() => {
  return vulnerablePackages.value.reduce((total, pkg) => {
    return total + pkg.vulnerabilities.length;
  }, 0);
});
</script>

<template>
  <!-- Only show the component if we have content to analyze -->
  <div class="max-w-4xl mx-auto p-5 bg-white rounded-lg shadow-md">
    <!-- Content header with title and back button -->
    <div class="flex justify-between items-center mb-6">
      <div>
        <h2 class="text-xl font-semibold">{{ contentTitle }}</h2>
        <div class="flex flex-wrap space-x-2">
          <p class="text-sm text-gray-500">
            {{ contentStore.currentContentId }}
          </p>
          <a
            v-if="dashboardUrl"
            :href="dashboardUrl"
            target="_blank"
            rel="noopener noreferrer"
            class="text-sm text-blue-600 hover:text-blue-800 flex items-center"
          >
            <span>View on Connect</span>
            <ArrowTopRight class="ml-1" />
          </a>
        </div>
      </div>

      <button
        @click="goBack"
        class="px-4 py-2 bg-gray-100 shrink-0 cursor-pointer hover:bg-gray-200 text-gray-800 rounded-md transition-colors"
      >
        ‚Üê Back to Content List
      </button>
    </div>

    <!-- Loading state -->
    <LoadingSpinner v-if="isLoading" :message="loadingMessage" size="md" />

    <!-- Error state -->
    <StatusMessage
      v-else-if="hasError"
      type="error"
      message="Error analyzing packages. The content may not be fully deployed."
    />

    <!-- Content loaded successfully -->
    <template v-else>
      <StatsPanel
        :totalPackages="totalPackages"
        :pythonPackages="pythonPackages"
        :rPackages="rPackages"
        :vulnerabilities="totalVulnerabilities"
      />

      <EmptyState v-if="!hasPackages">
        <p>This content has no packages. No vulnerabilities found.</p>
      </EmptyState>

      <EmptyState v-else-if="vulnerablePackages.length === 0">
        <p>No vulnerabilities found.</p>
      </EmptyState>

      <VulnerabilityList v-else :vulnerablePackages="vulnerablePackages" />
    </template>
  </div>
</template>
